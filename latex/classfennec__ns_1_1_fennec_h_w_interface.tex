\hypertarget{classfennec__ns_1_1_fennec_h_w_interface}{}\section{fennec\+\_\+ns\+:\+:Fennec\+H\+W\+Interface Class Reference}
\label{classfennec__ns_1_1_fennec_h_w_interface}\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}


Hardware interface for a robot.  




{\ttfamily \#include $<$fennec\+\_\+hw\+\_\+interface.\+h$>$}



Inheritance diagram for fennec\+\_\+ns\+:\+:Fennec\+H\+W\+Interface\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=235pt]{classfennec__ns_1_1_fennec_h_w_interface__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for fennec\+\_\+ns\+:\+:Fennec\+H\+W\+Interface\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classfennec__ns_1_1_fennec_h_w_interface__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a2efa0dd31094aa112588ba5ca1ff6f69}{Fennec\+H\+W\+Interface} (ros\+::\+Node\+Handle \&nh, urdf\+::\+Model $\ast$urdf\+\_\+model=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a26858f1a85875199f276e12d5fe30113}\label{classfennec__ns_1_1_fennec_h_w_interface_a26858f1a85875199f276e12d5fe30113}} 
virtual \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a26858f1a85875199f276e12d5fe30113}{$\sim$\+Fennec\+H\+W\+Interface} ()
\begin{DoxyCompactList}\small\item\em Destroy the Fennec HW Interface\+:\+: Fennec HW Interface object. \end{DoxyCompactList}\item 
virtual void \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_ad5e55d24cc4471e666f2e5e17977ca13}{init} ()
\begin{DoxyCompactList}\small\item\em Initialize the robot hardware interface. \end{DoxyCompactList}\item 
virtual void \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_adb8bbfce4a97c7f0a007a6ddf933be7a}{read} (ros\+::\+Duration \&elapsed\+\_\+time)
\begin{DoxyCompactList}\small\item\em Read the state from the robot hardware. \end{DoxyCompactList}\item 
virtual void \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a0b68acf47d161d3c7d30d21b35327923}{write} (ros\+::\+Duration \&elapsed\+\_\+time)
\begin{DoxyCompactList}\small\item\em Write the command to the robot hardware. \end{DoxyCompactList}\item 
virtual void \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a30250e644ed2ef16ee724289c8193066}{enforce\+Limits} (ros\+::\+Duration \&period)
\item 
void \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a918620ccc3c2bc7852b2f9e5fa90c54c}{encoder\+Callback} (const std\+\_\+msgs\+::\+Int16\+::\+Const\+Ptr \&msg)
\begin{DoxyCompactList}\small\item\em Counts the pulses of the encoder. Gets called everytime the rosserial node publishes a new msg. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_ae3d579b889bed76ab21335d767ac4ed4}\label{classfennec__ns_1_1_fennec_h_w_interface_ae3d579b889bed76ab21335d767ac4ed4}} 
void \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_ae3d579b889bed76ab21335d767ac4ed4}{print\+Commands} ()
\begin{DoxyCompactList}\small\item\em A helper function to print the R\+OS Controller Commands for each control loop to the console. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a9e450fc1f1b96701f89be637a58622a9}\label{classfennec__ns_1_1_fennec_h_w_interface_a9e450fc1f1b96701f89be637a58622a9}} 
const char $\ast$ \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a9e450fc1f1b96701f89be637a58622a9}{m\+\_\+i2c\+\_\+device\+\_\+name} = \char`\"{}/dev/i2c-\/1\char`\"{}
\begin{DoxyCompactList}\small\item\em The I2C Bus 1 is used by the \hyperlink{class_p_c_a9685}{P\+C\+A9685} boards. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a62c8cef371f076986ead0942304d134c}\label{classfennec__ns_1_1_fennec_h_w_interface_a62c8cef371f076986ead0942304d134c}} 
\hyperlink{class_i2_c___driver}{I2\+C\+\_\+\+Driver} $\ast$ {\bfseries m\+\_\+i2c\+\_\+driver} = new \hyperlink{class_i2_c___driver}{I2\+C\+\_\+\+Driver}(\hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a9e450fc1f1b96701f89be637a58622a9}{m\+\_\+i2c\+\_\+device\+\_\+name})
\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_aad562b8627b08e5dfdda168ade82530d}\label{classfennec__ns_1_1_fennec_h_w_interface_aad562b8627b08e5dfdda168ade82530d}} 
const uint8\+\_\+t \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_aad562b8627b08e5dfdda168ade82530d}{m\+\_\+steering\+\_\+pca9685\+\_\+address} = 0x40
\begin{DoxyCompactList}\small\item\em The default adress for a \hyperlink{class_p_c_a9685}{P\+C\+A9685} board. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_af8ebee84c63d1be3c949d58ab6087dbc}\label{classfennec__ns_1_1_fennec_h_w_interface_af8ebee84c63d1be3c949d58ab6087dbc}} 
\hyperlink{class_p_c_a9685}{P\+C\+A9685} $\ast$ {\bfseries m\+\_\+pca9685\+\_\+servo\+\_\+driver} = new \hyperlink{class_p_c_a9685}{P\+C\+A9685}(m\+\_\+i2c\+\_\+driver, \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_aad562b8627b08e5dfdda168ade82530d}{m\+\_\+steering\+\_\+pca9685\+\_\+address})
\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a515996ba43ee57670c6275b560997876}\label{classfennec__ns_1_1_fennec_h_w_interface_a515996ba43ee57670c6275b560997876}} 
const uint8\+\_\+t \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a515996ba43ee57670c6275b560997876}{m\+\_\+throttle\+\_\+pca9685\+\_\+address} = 0x60
\begin{DoxyCompactList}\small\item\em The adress of the 2nd \hyperlink{class_p_c_a9685}{P\+C\+A9685} board. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a6a6def1f04ecb0ca88b659aca69cfa60}\label{classfennec__ns_1_1_fennec_h_w_interface_a6a6def1f04ecb0ca88b659aca69cfa60}} 
\hyperlink{class_p_c_a9685}{P\+C\+A9685} $\ast$ {\bfseries m\+\_\+pca9685\+\_\+throttle\+\_\+driver} = new \hyperlink{class_p_c_a9685}{P\+C\+A9685}(m\+\_\+i2c\+\_\+driver, \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a515996ba43ee57670c6275b560997876}{m\+\_\+throttle\+\_\+pca9685\+\_\+address})
\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_ab1ca5a0a877c3bd02fcc2c93c8b85e60}\label{classfennec__ns_1_1_fennec_h_w_interface_ab1ca5a0a877c3bd02fcc2c93c8b85e60}} 
int16\+\_\+t \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_ab1ca5a0a877c3bd02fcc2c93c8b85e60}{m\+\_\+old\+\_\+num\+\_\+pulses}
\begin{DoxyCompactList}\small\item\em Needed for calculating the driven rear wheel distance. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a117444fd6f01a83c603bc3ff6b7a3ffe}\label{classfennec__ns_1_1_fennec_h_w_interface_a117444fd6f01a83c603bc3ff6b7a3ffe}} 
int \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a117444fd6f01a83c603bc3ff6b7a3ffe}{m\+\_\+difference\+\_\+num\+\_\+of\+\_\+pulses}
\begin{DoxyCompactList}\small\item\em Needed for calculating the driven rear wheel distance. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a2ff004471cd398edf8ab25e0e34d8f2e}\label{classfennec__ns_1_1_fennec_h_w_interface_a2ff004471cd398edf8ab25e0e34d8f2e}} 
int \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a2ff004471cd398edf8ab25e0e34d8f2e}{m\+\_\+difference\+\_\+num\+\_\+pulses\+\_\+since\+\_\+last\+\_\+read}
\begin{DoxyCompactList}\small\item\em Needed for calculating the driven rear wheel distance. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_af8946e6a059010374d152c428e75c252}\label{classfennec__ns_1_1_fennec_h_w_interface_af8946e6a059010374d152c428e75c252}} 
const u\+\_\+int8\+\_\+t {\bfseries servo\+\_\+channel} = 0
\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a57306686ca8d401e8ee6c71c77c2b47c}\label{classfennec__ns_1_1_fennec_h_w_interface_a57306686ca8d401e8ee6c71c77c2b47c}} 
ros\+::\+Subscriber \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_a57306686ca8d401e8ee6c71c77c2b47c}{rosserial\+\_\+sub}
\begin{DoxyCompactList}\small\item\em Subscriber to the /encoder\+\_\+pulses topic, which is published by the Arduino. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_afdb8c91b694144d8f4cd05780e15b0c1}\label{classfennec__ns_1_1_fennec_h_w_interface_afdb8c91b694144d8f4cd05780e15b0c1}} 
bool \hyperlink{classfennec__ns_1_1_fennec_h_w_interface_afdb8c91b694144d8f4cd05780e15b0c1}{logging}
\begin{DoxyCompactList}\small\item\em Can be changed at runtime with a R\+OS Param. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Hardware interface for a robot. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a2efa0dd31094aa112588ba5ca1ff6f69}\label{classfennec__ns_1_1_fennec_h_w_interface_a2efa0dd31094aa112588ba5ca1ff6f69}} 
\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}!Fennec\+H\+W\+Interface@{Fennec\+H\+W\+Interface}}
\index{Fennec\+H\+W\+Interface@{Fennec\+H\+W\+Interface}!fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}
\subsubsection{\texorpdfstring{Fennec\+H\+W\+Interface()}{FennecHWInterface()}}
{\footnotesize\ttfamily fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface\+::\+Fennec\+H\+W\+Interface (\begin{DoxyParamCaption}\item[{ros\+::\+Node\+Handle \&}]{nh,  }\item[{urdf\+::\+Model $\ast$}]{urdf\+\_\+model = {\ttfamily NULL} }\end{DoxyParamCaption})}



Constructor. 


\begin{DoxyParams}{Parameters}
{\em nh} & -\/ Node handle for topics. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a918620ccc3c2bc7852b2f9e5fa90c54c}\label{classfennec__ns_1_1_fennec_h_w_interface_a918620ccc3c2bc7852b2f9e5fa90c54c}} 
\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}!encoder\+Callback@{encoder\+Callback}}
\index{encoder\+Callback@{encoder\+Callback}!fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}
\subsubsection{\texorpdfstring{encoder\+Callback()}{encoderCallback()}}
{\footnotesize\ttfamily void fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface\+::encoder\+Callback (\begin{DoxyParamCaption}\item[{const std\+\_\+msgs\+::\+Int16\+::\+Const\+Ptr \&}]{msg }\end{DoxyParamCaption})}



Counts the pulses of the encoder. Gets called everytime the rosserial node publishes a new msg. 


\begin{DoxyParams}{Parameters}
{\em msg} & The current number of pulses, counted by the Arduino, range is from -\/32768 to 32767 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a30250e644ed2ef16ee724289c8193066}\label{classfennec__ns_1_1_fennec_h_w_interface_a30250e644ed2ef16ee724289c8193066}} 
\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}!enforce\+Limits@{enforce\+Limits}}
\index{enforce\+Limits@{enforce\+Limits}!fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}
\subsubsection{\texorpdfstring{enforce\+Limits()}{enforceLimits()}}
{\footnotesize\ttfamily void fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface\+::enforce\+Limits (\begin{DoxyParamCaption}\item[{ros\+::\+Duration \&}]{period }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Enforce limits for all values before writing \mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_ad5e55d24cc4471e666f2e5e17977ca13}\label{classfennec__ns_1_1_fennec_h_w_interface_ad5e55d24cc4471e666f2e5e17977ca13}} 
\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}!init@{init}}
\index{init@{init}!fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}
\subsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface\+::init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Initialize the robot hardware interface. 

Open up the I2C communication and try to connect to the two \hyperlink{class_p_c_a9685}{P\+C\+A9685} boards for the motors. \mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_adb8bbfce4a97c7f0a007a6ddf933be7a}\label{classfennec__ns_1_1_fennec_h_w_interface_adb8bbfce4a97c7f0a007a6ddf933be7a}} 
\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}!read@{read}}
\index{read@{read}!fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}
\subsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily void fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface\+::read (\begin{DoxyParamCaption}\item[{ros\+::\+Duration \&}]{elapsed\+\_\+time }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Read the state from the robot hardware. 

Gets called in every update cycle of the controller manager Updating the joint positions and velocities for the robot Counting the steps from the encoder motors and reading the current pwm from the servo motor to get the current values We want to overwrite the states of the robot stored in these variables std\+::vector$<$double$>$ joint\+\_\+position\+\_\+; std\+::vector$<$double$>$ joint\+\_\+velocity\+\_\+; std\+::vector$<$double$>$ joint\+\_\+effort\+\_\+; Joint index 0\+: front\+\_\+steer\+\_\+joint, 1\+: rear\+\_\+wheel\+\_\+joint.

Steer Joint Readings Read the on and off bytes of the Servo P\+C\+A9865 Frequency of the servo is 50 Hz (common Hz for Servos) Pulse Length is 20ms This pulse is divided into 4096 ticks Servos expect a pulse length of 1 milliseconds to 2 milliseconds 1 ms = 0 degree, 2ms = 180 degree this result in the length of the on bytes to be between 204 bytes(4096 ticks/20ms $\ast$ 1ms) and 409 bytes (4096 ticks/20ms $\ast$ 2ms) respectively with this information we can determine the position of the servo motor and write that in the joint\+\_\+position\+\_\+\mbox{[}1\mbox{]} The maximum steering angle of the front wheels is around 24 degrees in either direction this equals around 0,4189 radians R\+OS Control expects the unit to be rad/s which is the angular velocity

Some important formulas for the calculation of the steering angle based on the read information from the P\+WM Signal\+: Steering angle (in degree) = atan(wheelbase / turning\+\_\+radius) turning\+\_\+radius = wheelbase / tan(steering\+\_\+angle) Angular Velocity = speed (m/s) $\ast$ tan(steering\+\_\+angle) (rad) / wheelbase (m)

We have the problem that when the robot is driving backwards the odometry only cares for the rad/s (the change of rad/s to be specific) for that when we update the joint position and velocity we have to take into account in which direction we are driving If we are driving backwards we want to reverse the rad/s For forward driving we dont have to change anything


\begin{DoxyParams}{Parameters}
{\em elapsed\+\_\+time} & Time since the last update cycle \\
\hline
\end{DoxyParams}
Determining the steering angle

Mapping to Value Ranges to one another\mbox{\Hypertarget{classfennec__ns_1_1_fennec_h_w_interface_a0b68acf47d161d3c7d30d21b35327923}\label{classfennec__ns_1_1_fennec_h_w_interface_a0b68acf47d161d3c7d30d21b35327923}} 
\index{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}!write@{write}}
\index{write@{write}!fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface@{fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface}}
\subsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily void fennec\+\_\+ns\+::\+Fennec\+H\+W\+Interface\+::write (\begin{DoxyParamCaption}\item[{ros\+::\+Duration \&}]{elapsed\+\_\+time }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Write the command to the robot hardware. 

Write the commands by R\+OS Control to the P\+CA 9685 motor drivers Controlling the servo (Position\+Joint\+Interface) The joint\+\_\+position\+\_\+command\+\_\+ gives us a radian to work with from 0 to 3.\+141 we then translate that to the need pwm for the servo.

DC Motors std\+::vector$<$double$>$ joint\+\_\+velocity\+\_\+command\+\_\+\mbox{[}0\mbox{]} unit is rad/s e.\+g. 6.\+28/sec = 1 rev/sec 1 revolution equal 700 pulses by the encoder at 1600hz for the motors the maximum pwm in 0,000625s = 0,625ms = 625 microseconds

According to the speed test the motor at maximum pwm\+\_\+pulse\+\_\+width (tested with jetracer python library by nvidia/waveshare) turns 3,9 times/sec which equal 24,5 rad/s (2pi$\ast$3,9) or 84 cm/s = 0,84 m/s (with wheel circumference = 21,5 cm)


\begin{DoxyParams}{Parameters}
{\em elapsed\+\_\+time} & The time since the last update loop \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fennec\+\_\+control/include/fennec\+\_\+control/fennec\+\_\+hw\+\_\+interface.\+h\item 
fennec\+\_\+control/src/fennec\+\_\+hw\+\_\+interface.\+cpp\end{DoxyCompactItemize}
